"okay"
}
if(any(unique(model$model) < 10)) {
warning('You may have a factor variable. If so, correlation is not appropriate')
}
if(any(unique(model$model) < 1)) {
warning('You may have a factor variable. If so, correlation is not appropriate')
}
cor_problem <- ifelse(correlation > 0.2,
"potential problem", "no problem")
cor_problem
cor_output <-cbind(paste0("conditional mean: ",
variable.names(model)), signif(correlation, 3), cor_problem)
correlation <- sapply(model$model,
function(x) ifelse(is.factor(x),
max(abs(tapply(resid, x, mean))),
cor(resid, x)))
cor_output <-cbind(paste0("conditional mean: ",
variable.names(model)), signif(correlation, 3), cor_problem)
correlation <- sapply(model2$model,
function(x) ifelse(is.factor(x),
max(abs(tapply(resid, x, mean))),
cor(resid, x)))
resid2 <- stats::residuals(model)
resid <- stats::residuals(model2)
correlation <- sapply(model2$model,
function(x) ifelse(is.factor(x),
max(abs(tapply(resid, x, mean))),
cor(resid, x)))
correlation
cor_problem <- ifelse(correlation > 0.2,
"potential problem", "no problem")
cor_problem
cor_output <-cbind(paste0("conditional mean: ",
variable.names(model)), signif(correlation, 3), cor_problem)
cor_output <-cbind(paste0("conditional mean: ",
variable.names(model2)), signif(correlation, 3), cor_problem)
cor_output
correlation_output <- cor_output[-1,]
correlation_outpu
correlation_output
```{r}
testing <- data.frame(rbind(tests, vif, correlation_output))
rownames(testing) <- c()
testing
check_assumptions <- function(model_name) {
####
# adds residuals
####
resid <- residuals(model_name)
####
# Most tests
####
normality <- moments::jarque.test(resid) # residual test
constant_variance <- car::ncvTest(model_name) # constant variance
autocorrelation <- car::durbinWatsonTest(model_name) # autocorrelation
# putting most tests together
tests <- c("normality", "constant variance", "auto correlation")
values <- c(signif(as.numeric(normality$p.value), 3),
signif(as.numeric(constant_variance$p), 3), signif(as.numeric(autocorrelation$p), 3))
problems <- ifelse(values < 0.05, "problem", "no problem")
tests <- cbind(tests, values, problems)
####
# adding multicollinearity
####
viffy <- ifelse(length(model_name$coefficients) < 3,
"only one IV", max(round(car::vif(model_name), 3)))
viffy_results <- ifelse(viffy == "only one IV", NA,
ifelse(viffy > 10, "problem",
ifelse(viffy > 4, "potential problem", "no problem")))
vif <- c("multicollinearity: vif", viffy, viffy_results)
####
# adding conditional mean of the errors
####
# running correlation between variables and residual (conditional mean of error is zero)
correlation <- sapply(model_name$model,
function(x) ifelse(is.factor(x),
max(abs(tapply(resid, x, mean))),
cor(resid, x)))
if(any(unique(model$model) < 10)) {
warning('You may have a factor variable. If so, correlation is not appropriate')
}
cor_problem <- ifelse(correlation > 0.2,
"potential problem", "no problem")
cor_output <-cbind(paste0("conditional mean: ",
variable.names(model_name)), signif(correlation, 3), cor_problem)
correlation_output <- cor_output[-1,]
# creating the object to return
testing <- data.frame(rbind(tests, vif, correlation_output))
rownames(testing) <- c()
# testing$values <- round(as.numeric(testing$values), 3)
return(testing)
}
check_assumptions(model)
check_assumptions(model2)
check_assumptions <- function(model_name) {
####
# adds residuals
####
resid <- residuals(model_name)
####
# Most tests
####
normality <- moments::jarque.test(resid) # residual test
constant_variance <- car::ncvTest(model_name) # constant variance
autocorrelation <- car::durbinWatsonTest(model_name) # autocorrelation
# putting most tests together
tests <- c("normality", "constant variance", "auto correlation")
values <- c(signif(as.numeric(normality$p.value), 3),
signif(as.numeric(constant_variance$p), 3), signif(as.numeric(autocorrelation$p), 3))
problems <- ifelse(values < 0.05, "problem", "no problem")
tests <- cbind(tests, values, problems)
####
# adding multicollinearity
####
viffy <- ifelse(length(model_name$coefficients) < 3,
"only one IV", max(round(car::vif(model_name), 3)))
viffy_results <- ifelse(viffy == "only one IV", NA,
ifelse(viffy > 10, "problem",
ifelse(viffy > 4, "potential problem", "no problem")))
vif <- c("multicollinearity: vif", viffy, viffy_results)
####
# adding conditional mean of the errors
####
# running correlation between variables and residual (conditional mean of error is zero)
correlation <- sapply(model_name$model,
function(x) ifelse(is.factor(x),
max(abs(tapply(resid, x, mean))),
cor(resid, x)))
if(any(unique(model$model) < 10)) {
warning('You may have a factor variable. If so, correlation is not appropriate.')
}
cor_problem <- ifelse(correlation > 0.2,
"potential problem", "no problem")
cor_output <-cbind(paste0("conditional mean: ",
variable.names(model_name)), signif(correlation, 3), cor_problem)
correlation_output <- cor_output[-1,]
# creating the object to return
testing <- data.frame(rbind(tests, vif, correlation_output))
rownames(testing) <- c()
# testing$values <- round(as.numeric(testing$values), 3)
return(testing)
}
check_assumptions(model)
check_assumptions(model2)
check_assumptions <- function(model_name) {
####
# adds residuals
####
resid <- residuals(model_name)
####
# Most tests
####
normality <- moments::jarque.test(resid) # residual test
constant_variance <- car::ncvTest(model_name) # constant variance
autocorrelation <- car::durbinWatsonTest(model_name) # autocorrelation
# putting most tests together
tests <- c("normality", "constant variance", "auto correlation")
values <- c(signif(as.numeric(normality$p.value), 3),
signif(as.numeric(constant_variance$p), 3), signif(as.numeric(autocorrelation$p), 3))
problems <- ifelse(values < 0.05, "problem", "no problem")
tests <- cbind(tests, values, problems)
####
# adding multicollinearity
####
viffy <- ifelse(length(model_name$coefficients) < 3,
"only one IV", max(round(car::vif(model_name), 3)))
viffy_results <- ifelse(viffy == "only one IV", NA,
ifelse(viffy > 10, "problem",
ifelse(viffy > 4, "potential problem", "no problem")))
vif <- c("multicollinearity: vif", viffy, viffy_results)
####
# adding conditional mean of the errors
####
# running correlation between variables and residual (conditional mean of error is zero)
correlation <- sapply(model_name$model,
function(x) ifelse(is.factor(x),
max(abs(tapply(resid, x, mean))),
cor(resid, x)))
if(any(unique(model$model) < 10)) {
warning('You may have a factor variable. If so, correlation is not appropriate.')
}
cor_problem <- ifelse(correlation > 0.2,
"potential problem", "no problem")
cor_output <-cbind(paste0("conditional mean: ",
variable.names(model_name)), signif(correlation, 3), cor_problem)
correlation_output <- cor_output[-1,]
# creating the object to return
testing <- data.frame(rbind(tests, vif, correlation_output))
rownames(testing) <- c()
# testing$values <- round(as.numeric(testing$values), 3)
return(testing)
}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(readxl)
library(broom)
library(stargazer)
library(car)
library(modelr)
library(researchr)
library(cowplot)
library(psych)
library(moments)
library(lmtest)
library(modelsummary)
library(gt)
school_1_raw <- read_excel("R:/Level 2/17-18_School 1.xlsx")
# LSSSE variables we want to consider
lssse_vars <- read_csv("R:/Level 2/Second Round/Data/lssse_variables_to_consider.csv")
school_1_raw %>%
count(Race) # using this to iteratively find which races need to be collapsed
school_1_raw %>%
count(Gender) # checking gender categories
school_1_raw %>%
count(Jurisdiction) # checking number of jurisdictions and observations by jurisdictions
school_1 <- school_1_raw %>%
select(BarScore, Sem1_GPA, Yr1_GPA, Final_GPA, LSAT, UGPA,
Race, Gender, lssse_vars$lssse_variables) %>%
mutate(Race2 = as.factor(ifelse(Race %in% c("Nonresident alien",
"Race and Ethnicity Unknown",
"Two or More Races"), "Other Race", Race)),
Gender = as.factor(Gender)) %>%
select(-Race)
check_missing_variables(school_1) # checking which variables are missing data
distributions <- apply(school_1[7:65], 2, table)
proportions <- map(distributions, prop.table)
proportions # look for categories with fewer than 10% for each variable
recode <- proportions %>%
map(function(x) any(x < 0.1)) # which ones need to be recoded
drop <- proportions %>%
map(function(x) any(x > 0.9)) # which ones to drop
model_data <- school_1 %>%
select(-internat, -enrolday, -enter, -fundneed, -parenteduc,
-Sem1_GPA, -Yr1_GPA) %>%
mutate(rewropap = ifelse(rewropap < 3, 0, 1),
integrat = ifelse(integrat < 3, 0 ,1),
clunprep = ifelse(clunprep < 2, 0, 1),
classgrp = ifelse(classgrp < 2, 0, 1),
occgrp = ifelse(occgrp < 2, 0, 1),
intideas = ifelse(intideas < 3, 0, 1),
workhard = ifelse(workhard < 3, 0, 1),
oocideas = ifelse(oocideas < 3, 0, 1),
diffstud = ifelse(diffstud < 3, 0, 1),
exams = ifelse(exams < 4, 0, (exams - 3)),
memorize = ifelse(memorize < 3, 0, 1),
analyze = ifelse(analyze < 3, 0, 1),
synthesz = ifelse(synthesz < 3, 0, 1),
evaluate = ifelse(evaluate < 3, 0, 1),
applying = ifelse(applying < 3, 0, 1),
writemor = ifelse(writemor < 2, 0, 1),
writemid = ifelse(writemid < 2, 0, 1),
writesml = ifelse(writesml < 2, 0, 1),
readasgn = ifelse(readasgn < 4, 0, 1),
acadprep = ifelse(acadprep < 4, 0, 1),
readown = ifelse(readown < 2, 0, 1),
worklegl = ifelse(worklegl < 2, 0, 1),
worknleg = ifelse(worknleg < 2, 0, 1),
cocurric = ifelse(cocurric < 3, 0, 1),
exercise = ifelse(exercise < 3, 0, 1),
social = ifelse(social < 3, 0, 1),
caredep = ifelse(caredep < 2, 0, 1),
envschol = ifelse(envschol < 3, 0, 1),
envsuprt = ifelse(envsuprt < 3, 0, 1),
envnacad = ifelse(envnacad < 2, 0, 1),
envfinan = ifelse(envfinan < 2, 0, 1),
envfac = ifelse(envfac < 3, 0,
ifelse(envfac == 4, 1, 2)),
envadm = ifelse(envadm < 3, 0,
ifelse(envadm == 4, 1, 2)),
gnleged = ifelse(gnleged < 3, 0, 1),
gnwork = ifelse(gnwork < 3, 0, 1),
gnwrite = ifelse(gnwrite < 3, 0, 1),
gnanaly = ifelse(gnanaly < 3, 0, 1),
gnresrch = ifelse(gnresrch < 3, 0, 1),
gnown = ifelse(gnown < 3, 0, 1),
gnprobsv = ifelse(gnprobsv < 3, 0, 1),
entirexp = ifelse(entirexp < 3, 0, 1),
debt16 = ifelse(debt16 < 5, 0, 1),
clquest = ifelse(clquest < 3, 0, 1),
clinproj = clinproj - 1,
facfeed = facfeed - 1,
firstgen = firstgen - 1,
sameschl16 = ifelse(sameschl16 < 3, 0, 1))
bivariate_results <- researchr::explore_bivariate(model_data, "BarScore", names(model_data[,-1]), p_value = 0.1, type = "table") %>%
filter(significance == 1) %>%
arrange(p.value)
bivariate_results # table of significant variables that deserve greater consideration
# Creating a list of all variables that are significant, control variables, and the DV
independent_variables <- bivariate_results$term %>%
as_tibble() %>%
filter(!(value %in% c("Race2White", "GenderMale"))) %>%
rbind("Race2", "Gender", "Final_GPA", "BarScore") %>%
as.vector()
# creating a dataset with only variables we want and omitting missing obs (not ideal, but necessary)
step_data <- school_1 %>%
select(independent_variables$value) %>%
na.omit()
# creating smallest possible model
minimal_model <- lm(BarScore ~ 1, data = step_data)
# create a most complete model (which violates a lot of assumptions right away)
full_model <- lm(BarScore ~ ., data = step_data)
# having step figure out which model has best fit (still likely violates assumptions and is not final product)
step_model <- step(minimal_model, scope = list(lower = minimal_model,
upper = full_model), direction = "forward")
# seeing the suggested model
summary(step_model)
# Using both the step and bivariate tests, I have come up with the following.
# Partially based off what I thought was of practical importance to school.
final_lssse_model <- lm(BarScore ~ Final_GPA + Race2 + Gender + LSAT + UGPA + fundmerit +
caredep + social,
data = model_data)
# It is likely worth mentioning that LSAT and UGPA influences are cut down
# in half when including LSSSE variable (good for our narrative)
summary(final_lssse_model)
check_assumptions(final_lssse_model)
check_assumptions <- function(model_name) {
####
# adds residuals
####
resid <- residuals(model_name)
####
# Most tests
####
normality <- moments::jarque.test(resid) # residual test
constant_variance <- car::ncvTest(model_name) # constant variance
autocorrelation <- car::durbinWatsonTest(model_name) # autocorrelation
# putting most tests together
tests <- c("normality", "constant variance", "auto correlation")
values <- c(signif(as.numeric(normality$p.value), 3),
signif(as.numeric(constant_variance$p), 3), signif(as.numeric(autocorrelation$p), 3))
problems <- ifelse(values < 0.05, "problem", "no problem")
tests <- cbind(tests, values, problems)
####
# adding multicollinearity
####
viffy <- ifelse(length(model_name$coefficients) < 3,
"only one IV", max(round(car::vif(model_name), 3)))
viffy_results <- ifelse(viffy == "only one IV", NA,
ifelse(viffy > 10, "problem",
ifelse(viffy > 4, "potential problem", "no problem")))
vif <- c("multicollinearity: vif", viffy, viffy_results)
####
# adding conditional mean of the errors
####
# running correlation between variables and residual (conditional mean of error is zero)
correlation <- sapply(model_name$model,
function(x) ifelse(is.factor(x),
max(abs(tapply(resid, x, mean))),
cor(resid, x)))
if(any(unique(model_nam$model) < 10)) {
warning('You may have a factor variable. If so, correlation is not appropriate.')
}
cor_problem <- ifelse(correlation > 0.2,
"potential problem", "no problem")
cor_output <-cbind(paste0("conditional mean: ",
variable.names(model_name)), signif(correlation, 3), cor_problem)
correlation_output <- cor_output[-1,]
# creating the object to return
testing <- data.frame(rbind(tests, vif, correlation_output))
rownames(testing) <- c()
# testing$values <- round(as.numeric(testing$values), 3)
return(testing)
}
check_assumptions(final_lssse_model)
check_assumptions <- function(model_name) {
####
# adds residuals
####
resid <- residuals(model_name)
####
# Most tests
####
normality <- moments::jarque.test(resid) # residual test
constant_variance <- car::ncvTest(model_name) # constant variance
autocorrelation <- car::durbinWatsonTest(model_name) # autocorrelation
# putting most tests together
tests <- c("normality", "constant variance", "auto correlation")
values <- c(signif(as.numeric(normality$p.value), 3),
signif(as.numeric(constant_variance$p), 3), signif(as.numeric(autocorrelation$p), 3))
problems <- ifelse(values < 0.05, "problem", "no problem")
tests <- cbind(tests, values, problems)
####
# adding multicollinearity
####
viffy <- ifelse(length(model_name$coefficients) < 3,
"only one IV", max(round(car::vif(model_name), 3)))
viffy_results <- ifelse(viffy == "only one IV", NA,
ifelse(viffy > 10, "problem",
ifelse(viffy > 4, "potential problem", "no problem")))
vif <- c("multicollinearity: vif", viffy, viffy_results)
####
# adding conditional mean of the errors
####
# running correlation between variables and residual (conditional mean of error is zero)
correlation <- sapply(model_name$model,
function(x) ifelse(is.factor(x),
max(abs(tapply(resid, x, mean))),
cor(resid, x)))
if(any(unique(model_name$model) < 10)) {
warning('You may have a factor variable. If so, correlation is not appropriate.')
}
cor_problem <- ifelse(correlation > 0.2,
"potential problem", "no problem")
cor_output <-cbind(paste0("conditional mean: ",
variable.names(model_name)), signif(correlation, 3), cor_problem)
correlation_output <- cor_output[-1,]
# creating the object to return
testing <- data.frame(rbind(tests, vif, correlation_output))
rownames(testing) <- c()
# testing$values <- round(as.numeric(testing$values), 3)
return(testing)
}
check_assumptions(final_lssse_model)
model1 <- lm(mpg ~ wt, data = mtcars)
model2 <- lm(mpg ~ wt + cyl + hp + wt + disp, data = mtcars)
explain_results <- function(model_name, variable) {
# extracting results
results <- broom::tidy(model_name) %>%
dplyr::mutate(directionality1 = ifelse(estimate < 0, "negative", "positive"),
directionality2 = ifelse(estimate < 0, "decreased", "increased"),
absolute_value = round(abs(estimate), 3)) %>%
dplyr::filter(term == variable)
# dependent variable
dv <- names(model_name$model)[1]
# independent variables
independent_variables <- names(model_name$model)[-1]
# output
if(length(independent_variables) < 2) {
return(paste0("The variable '", results$term, "' had a ", results$directionality1,
" relationship with '", dv,
"'. Where when '", results$term, "' went up by 1 unit, '", dv, "' ",
results$directionality2, " by ", results$absolute_value))
} else {
# controls
controls <- independent_variables %>%
tibble::as_tibble() %>%
dplyr::mutate(row_id = dplyr::row_number()) %>%
dplyr::filter(value != variable) %>% # interactive part
tidyr::spread(row_id, value) %>%
tidyr::unite("ivs", 1:ncol(.), sep = ", ")
return(paste0("The variable '", results$term, "' had a ", results$directionality1,
" relationship with '", dv,
"'. Where when '", results$term, "' went up by 1 unit, '", dv, "' ",
results$directionality2, " by ", results$absolute_value,
" while controlling for: ", controls))
# this last line spits out multiple rows.  That is a problem
}
}
summary(model2)
explain_results(model2, "hp")
library(tidyverse)
explain_results(model2, "hp")
results <- broom::tidy(model1) %>%
dplyr::mutate(directionality1 = ifelse(estimate < 0, "negative", "positive"),
directionality2 = ifelse(estimate < 0, "decreased", "increased"),
absolute_value = round(abs(estimate), 3)) %>%
dplyr::filter(term == hp)
results <- broom::tidy(model1) %>%
dplyr::mutate(directionality1 = ifelse(estimate < 0, "negative", "positive"),
directionality2 = ifelse(estimate < 0, "decreased", "increased"),
absolute_value = round(abs(estimate), 3)) %>%
dplyr::filter(term == "hp")
results
results <- broom::tidy(model2) %>%
dplyr::mutate(directionality1 = ifelse(estimate < 0, "negative", "positive"),
directionality2 = ifelse(estimate < 0, "decreased", "increased"),
absolute_value = round(abs(estimate), 3)) %>%
dplyr::filter(term == "hp")
results
explain_results <- function(model_name, variable, p_value = 0.05) {
# extracting results
results <- broom::tidy(model_name) %>%
dplyr::mutate(directionality1 = ifelse(estimate < 0, "negative", "positive"),
directionality2 = ifelse(estimate < 0, "decreased", "increased"),
absolute_value = round(abs(estimate), 3)) %>%
dplyr::filter(term == variable)
# dependent variable
dv <- names(model_name$model)[1]
# independent variables
independent_variables <- names(model_name$model)[-1]
# output
if(results$p.value > p_value) {
return(paste0("The variable '", results$term, "' is not significantly related to '",
dv, "'."))
} else if(length(independent_variables) < 2) {
return(paste0("The variable '", results$term, "' had a ", results$directionality1,
" relationship with '", dv,
"'. Where when '", results$term, "' went up by 1 unit, '", dv, "' ",
results$directionality2, " by ", results$absolute_value))
} else {
# controls
controls <- independent_variables %>%
tibble::as_tibble() %>%
dplyr::mutate(row_id = dplyr::row_number()) %>%
dplyr::filter(value != variable) %>% # interactive part
tidyr::spread(row_id, value) %>%
tidyr::unite("ivs", 1:ncol(.), sep = ", ")
return(paste0("The variable '", results$term, "' had a ", results$directionality1,
" relationship with '", dv,
"'. Where when '", results$term, "' went up by 1 unit, '", dv, "' ",
results$directionality2, " by ", results$absolute_value,
" while controlling for: ", controls))
# this last line spits out multiple rows.  That is a problem
}
}
explain_results(model1, "wt")
explain_results(model2, "hp")
explain_results(model2, "cyl")
summary(model2)
explain_results(model2, "wt")
explain_results(model2, "cyl", p_value = 0.1)
