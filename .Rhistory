library(devtools)
install_github("rgardiner90/researchr")
install_github("rgardiner90/researchr")
data(mtcars)
missing <- mtcars %>%
mutate(mpg = ifelse(mpg > 20, NA, mpg),)
missing <- mtcars %>%
mutate(mpg = ifelse(mpg > 20, NA, mpg),
cyl = ifelse(cyl == 6, NA, cyl))
missing <- mtcars %>%
mutate(mpg = ifelse(mpg > 20, NA, mpg),
cyl = ifelse(cyl == 6, NA, cyl))
library(tidyverse)
missing <- mtcars %>%
mutate(mpg = ifelse(mpg > 20, NA, mpg),
cyl = ifelse(cyl == 6, NA, cyl))
missing
researchr::check_missing_variables(missing)
library(researchr)
check_missing_variables(missing)
document("researchr")
document("researchr.R")
library(devtools)
document
document()
dir()
dir("researchr/man")
dir("/man")
dir("researcher\man")
help(researchr)
help(check_variable_assumptions)
??check_variable_assumptions
??check_variable_assumptions()
?check_missing_variables
library(devtools)
check("researchr")
check()
check()
check()
check()
document()
check()
??check_assumptions()
library(researchr)
?check_assumptions
check()
check()
# check_assumptions(model2)
#' Conditional mean looks at the correlation between the residuals and the numeric
#' variable.  Currently, it is unable to properly evaluate the influence of a
#' categorical variable.
#'
#' @examples
#' # model <- lm(dist ~ speed , data = cars) # running a model
#' # check_assumptions(model)
#'
#' # model2 <- lm(mpg ~ cyl + wt, data = mtcars)
#' # check_assumptions(model2)
check_assumptions <- function(model_name) {
####
# adds residuals
####
resid <- residuals(model_name)
####
# Most tests
####
normality <- moments::jarque.test(resid) # residual test
constant_variance <- car::ncvTest(model_name) # constant variance
autocorrelation <- car::durbinWatsonTest(model_name) # autocorrelation
# putting most tests together
tests <- c("normality", "constant variance", "auto correlation")
values <- c(signif(as.numeric(normality$p.value), 3),
signif(as.numeric(constant_variance$p), 3), signif(as.numeric(autocorrelation$p), 3))
problems <- ifelse(values < 0.05, "problem", "no problem")
tests <- cbind(tests, values, problems)
####
# adding multicollinearity
####
viffy <- ifelse(length(model_name$coefficients) < 3,
"only one IV", max(car::vif(model_name)))
viffy_results <- ifelse(viffy == "only one IV", "NA",
ifelse(viffy > 10, "problem",
ifelse(viffy > 4, "potential problem", "no problem")))
vif <- c("multicollinearity: vif", viffy, viffy_results)
####
# adding conditional mean of the errors
####
resid <- residuals(model_name)
# running correlation between variables and residual (conditional mean of error is zero)
correlation <- sapply(model_name$model,
function(x) ifelse(is.factor(x),
max(abs(tapply(resid, x, mean))),
cor(resid, x)))
cor_problem <- ifelse(correlation > 0.2,
"potential problem, unkown if factor", "no problem, unknown if factor")
cor_output <-cbind(paste0("conditional mean: ",
variable.names(model_name)), signif(correlation, 3), cor_problem)
correlation_output <- cor_output[-1,]
# creating the object to return
testing <- data.frame(rbind(tests, vif, correlation_output))
rownames(testing) <- c()
# testing$values <- round(as.numeric(testing$values), 3)
return(testing)
}
model <- lm(dist ~ speed , data = cars) # running a model
check_assumptions(model)
check()
#' categorical variable.
#'
#' @export
#'
#' @example
#' model <- lm(dist ~ speed , data = cars) # running a model
#' check_assumptions(model)
#'
#' model2 <- lm(mpg ~ cyl + wt, data = mtcars)
#' check_assumptions(model2)
check_assumptions <- function(model_name) {
####
# adds residuals
####
resid <- residuals(model_name)
####
# Most tests
####
normality <- moments::jarque.test(resid) # residual test
constant_variance <- car::ncvTest(model_name) # constant variance
autocorrelation <- car::durbinWatsonTest(model_name) # autocorrelation
# putting most tests together
tests <- c("normality", "constant variance", "auto correlation")
values <- c(signif(as.numeric(normality$p.value), 3),
signif(as.numeric(constant_variance$p), 3), signif(as.numeric(autocorrelation$p), 3))
problems <- ifelse(values < 0.05, "problem", "no problem")
tests <- cbind(tests, values, problems)
####
# adding multicollinearity
####
viffy <- ifelse(length(model_name$coefficients) < 3,
"only one IV", max(car::vif(model_name)))
viffy_results <- ifelse(viffy == "only one IV", "NA",
ifelse(viffy > 10, "problem",
ifelse(viffy > 4, "potential problem", "no problem")))
vif <- c("multicollinearity: vif", viffy, viffy_results)
####
# adding conditional mean of the errors
####
resid <- residuals(model_name)
# running correlation between variables and residual (conditional mean of error is zero)
correlation <- sapply(model_name$model,
function(x) ifelse(is.factor(x),
max(abs(tapply(resid, x, mean))),
cor(resid, x)))
cor_problem <- ifelse(correlation > 0.2,
"potential problem, unkown if factor", "no problem, unknown if factor")
cor_output <-cbind(paste0("conditional mean: ",
variable.names(model_name)), signif(correlation, 3), cor_problem)
correlation_output <- cor_output[-1,]
# creating the object to return
testing <- data.frame(rbind(tests, vif, correlation_output))
rownames(testing) <- c()
# testing$values <- round(as.numeric(testing$values), 3)
return(testing)
}
check()
check()
check()
check()
check()
check()
check()
check()
check()
check()
library(devtools)
check()
check()
check()
library(devtools)
check()
build("researchr")
model <- lm(mpg ~ ., data = cars)
model
cars
model <- lm(dist ~ ., data = cars)
model
library(researchr)
check_assumptions(model)
?check_assumptions
document()
devtools::document()
